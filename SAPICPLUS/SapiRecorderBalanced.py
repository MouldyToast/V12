#!/usr/bin/env python3
"""
SapiAgent Three-Dot Flow Recorder - BALANCED VERSION
Version: 8.0.0 - PRECOMPUTED BALANCED PATH

==============================================================================
KEY INNOVATION: ZERO-OVERHEAD GUARANTEED COVERAGE
==============================================================================
Instead of random dot spawning, this version follows a PRE-COMPUTED path that
guarantees perfect coverage of all (distance, orientation, turn) combinations.

Benefits:
- Every (distance Ã— orientation) combo recorded exactly 2Ã— (192 segments total)
- Turn categories balanced (27-28 each)
- All positions pre-validated for screen bounds
- ZERO runtime computation overhead

The path was generated by generate_balanced_sequence.py using constraint-based
optimization with geometric validation.

==============================================================================
RECORDING FLOW (same as v7.0.0)
==============================================================================
1. Session starts: A at center, B and C from precomputed path
2. User passes through A to begin recording
3. User moves toward B (seeing C, their path curves naturally)
4. User passes through B:
   - Segment Aâ†’B saved with C context
   - Dots shift to next positions in precomputed path
   - Recording continues (no pause!)
5. Repeat until 192 segments complete (full coverage)

==============================================================================
COVERAGE GUARANTEE
==============================================================================
    96 (distance Ã— orientation) combinations Ã— 2 = 192 segments
    
    Distance: 12 groups (27, 57, 117, 177, 237, 297, 357, 417, 477, 537, 597, 657)
    Orientation: 8 directions (N, NE, E, SE, S, SW, W, NW)
    Turn categories: 7 types, each ~27-28 occurrences

==============================================================================
OUTPUT STRUCTURE (same as v7.0.0)
==============================================================================
    output_dir/
    â””â”€â”€ segments/
        â”œâ”€â”€ segment_0001.json                 # Segment metadata + trajectory
        â””â”€â”€ ...

==============================================================================
USAGE
==============================================================================
    python SapiRecorderBalanced.py

Controls:
    - Pass through GREEN dot (A) to start recording
    - Pass through BLUE dot (B) to complete segment
    - Press Escape to end session early
    - Session auto-ends after 192 segments (full coverage)
"""

import tkinter as tk
import math

import json
import os
import time
import threading
from datetime import datetime
from pynput import mouse
from collections import defaultdict
import random

# =============================================================================
# PRECOMPUTED BALANCED PATH
# =============================================================================
# Generated by generate_balanced_sequence.py
# This encodes the entire recording session with guaranteed balanced coverage

from precomputed_paths_v2 import PATH_COUNT
path_number = random.randint(1, PATH_COUNT)
path_number_str = str(path_number)
PATH_NAME = "PRECOMPUTED_PATH_" + path_number_str

PRECOMPUTED_PATH = getattr(__import__('precomputed_paths_v2'), PATH_NAME)

# =============================================================================
# CONFIGURATION
# =============================================================================

# Visual
DOT_RADIUS = 30
DOT_A_COLOR = "#22c55e"      # Green - origin
DOT_B_COLOR = "#3b82f6"      # Blue - current target  
DOT_C_COLOR = "#f97316"      # Orange - next target (anticipation)
BACKGROUND_COLOR = "black"

# Session - determined by precomputed path
TARGET_SEGMENTS = len(PRECOMPUTED_PATH)  # 192 for full coverage
SESSION_DURATION_MS = 1800000  # 30 minute max (safety limit)

# Output
OUTPUT_DIR = r'D:\V12\V12_Anchors_Continuous\three_dot_flow'

# Screen constraints (must match generator settings)
SCREEN_WIDTH = 2560
SCREEN_HEIGHT = 1400
SCREEN_MARGIN = 10

# Sampling
SAMPLE_RATE_HZ = 125

# =============================================================================
# MOVEMENT PARAMETERS (must match generator)
# =============================================================================

DISTANCE_THRESHOLDS = [27, 57, 117, 177, 237, 297, 357, 417, 477, 537, 597, 657]
DISTANCE_NAMES = ["XXXS", "XXS", "XS", "S", "XXXM", "XXM", "XM", "M", "XXXL", "XXL", "XL", "L"]

ORIENTATIONS = ["N", "NE", "E", "SE", "S", "SW", "W", "NW"]

SCREEN_ANGLE_RANGES = {
    "E":  (-22.5, 22.5),
    "SE": (22.5, 67.5),
    "S":  (67.5, 112.5),
    "SW": (112.5, 157.5),
    "W":  (157.5, 180.0),
    "NW": (-157.5, -112.5),
    "N":  (-112.5, -67.5),
    "NE": (-67.5, -22.5),
}

ORIENT_VECTORS = {
    "N":  (0, -1),
    "NE": (0.707, -0.707),
    "E":  (1, 0),
    "SE": (0.707, 0.707),
    "S":  (0, 1),
    "SW": (-0.707, 0.707),
    "W":  (-1, 0),
    "NW": (-0.707, -0.707),
}

TURN_CATEGORIES = {
    "straight": (-25.7, 25.7),
    "slight_right": (25.7, 77.1),
    "hard_right": (77.1, 128.6),
    "reverse_right": (128.6, 180),
    "slight_left": (-77.1, -25.7),
    "hard_left": (-128.6, -77.1),
    "reverse_left": (-180, -128.6),
}


# =============================================================================
# HELPER FUNCTIONS
# =============================================================================

def angle_between_vectors(v1, v2):
    """Compute signed angle from v1 to v2 in degrees."""
    angle1 = math.atan2(v1[1], v1[0])
    angle2 = math.atan2(v2[1], v2[0])
    diff = angle2 - angle1
    while diff > math.pi:
        diff -= 2 * math.pi
    while diff < -math.pi:
        diff += 2 * math.pi
    return math.degrees(diff)


def get_orientation_from_angle(angle_deg):
    """Convert angle in degrees to orientation string."""
    if angle_deg > 157.5 or angle_deg <= -157.5:
        return "W"
    for orient, (lo, hi) in SCREEN_ANGLE_RANGES.items():
        if orient == "W":
            continue
        if lo <= angle_deg < hi:
            return orient
    return "E"


def get_orientation_id(orient_str):
    """Convert orientation string to ID (0-7)."""
    return ORIENTATIONS.index(orient_str)


def get_distance_group(distance):
    """Get distance group ID and name."""
    for i, threshold in enumerate(DISTANCE_THRESHOLDS):
        if i == 0:
            if distance < (threshold + DISTANCE_THRESHOLDS[1]) / 2:
                return i, DISTANCE_NAMES[i]
        elif i == len(DISTANCE_THRESHOLDS) - 1:
            return i, DISTANCE_NAMES[i]
        else:
            mid_low = (DISTANCE_THRESHOLDS[i-1] + threshold) / 2
            mid_high = (threshold + DISTANCE_THRESHOLDS[i+1]) / 2
            if mid_low <= distance < mid_high:
                return i, DISTANCE_NAMES[i]
    return len(DISTANCE_THRESHOLDS) - 1, DISTANCE_NAMES[-1]


def get_turn_category(turn_angle):
    """Categorize turn angle."""
    for category, (lo, hi) in TURN_CATEGORIES.items():
        if lo <= turn_angle < hi:
            return category
    return "straight"


def apply_move(pos, dist, orient):
    """Apply a move from position."""
    dx, dy = ORIENT_VECTORS[orient]
    return (pos[0] + dx * dist, pos[1] + dy * dist)


# =============================================================================
# BALANCED THREE-DOT RECORDER CLASS
# =============================================================================

class BalancedThreeDotRecorder:
    """
    Records mouse trajectories following a precomputed balanced path.
    Guarantees coverage of all (distance, orientation, turn) combinations.
    """
    
    def __init__(self, master):
        self.master = master
        self.master.title("SapiAgent Balanced Recorder v8.0.0")
        
        # Window setup
        self.width = SCREEN_WIDTH
        self.height = SCREEN_HEIGHT
        self.master.geometry(f"{self.width}x{self.height}")
        
        # Canvas
        self.canvas = tk.Canvas(master, bg=BACKGROUND_COLOR, highlightthickness=0)
        self.canvas.pack(fill=tk.BOTH, expand=True)
        
        # Session identification
        self.session_id = datetime.now().strftime("session_%Y_%m_%d_%H%M%S")
        self.session_start_time = None
        
        # Session state
        self.is_active = False
        self.recording_enabled = False
        self.segments_recorded = 0
        
        # PATH INDEX - key for balanced recording
        self.path_index = 0
        
        # The three dots
        self.dot_A = None
        self.dot_B = None
        self.dot_C = None
        
        # Current segment tracking
        self.segment_start_time = None
        self.segment_trajectory = []
        
        # Thread safety
        self.canvas_lock = threading.Lock()
        self.data_lock = threading.Lock()
        
        # Canvas position
        self.canvas_x = 0
        self.canvas_y = 0
        
        # Output directories
        self.output_dir = os.path.join(OUTPUT_DIR, self.session_id)
        self.segments_dir = os.path.join(self.output_dir, 'segments')
        os.makedirs(self.segments_dir, exist_ok=True)
        
        # Mouse controller
        self.mouse_controller = mouse.Controller()
        self.sampling_active = True
        self.sampling_thread = threading.Thread(target=self._sample_loop, daemon=True)
        
        # Entry detection state
        self._inside_A = False
        self._inside_B = False
        self._last_trigger_time = 0
        self._min_trigger_interval_ms = 100
        
        # Bindings
        self.canvas.bind("<Button-1>", self.on_click)
        self.master.bind("<Escape>", lambda e: self.end_session())
        self.master.protocol("WM_DELETE_WINDOW", self.end_session)
        
        # Start canvas position updater
        self.update_canvas_position()
        
        # Show startup screen
        self.show_startup_countdown(5)
        
        print(f"\n{'='*60}")
        print("BALANCED THREE-DOT RECORDER v8.0.0")
        print(f"{'='*60}")
        print(f"Precomputed path: {len(PRECOMPUTED_PATH)} segments")
        print(f"Coverage: 96 (dist Ã— orient) combos Ã— 2 = 192 segments")
        print(f"Turn categories: 7 types, ~27-28 each")
        print(f"\nInstructions:")
        print("  1. Pass through GREEN dot (A) - recording starts")
        print("  2. Move to BLUE dot (B) - see ORANGE dot (C) as NEXT target")
        print("  3. Pass through BLUE dot (B) - segment completes")
        print("  4. Follow the predetermined path for balanced coverage")
        print("  5. Press ESC to end early")
        print(f"{'='*60}")
    
    # =========================================================================
    # CANVAS POSITION TRACKING
    # =========================================================================
    
    def update_canvas_position(self):
        """Update canvas position for coordinate conversion."""
        try:
            with self.canvas_lock:
                self.canvas_x = self.canvas.winfo_rootx()
                self.canvas_y = self.canvas.winfo_rooty()
        except Exception:
            pass
        
        if self.sampling_active:
            self.master.after(100, self.update_canvas_position)
    
    def _is_inside_dot(self, x, y, dot, radius=None):
        """Check if point is inside a dot."""
        if dot is None:
            return False
        if radius is None:
            radius = DOT_RADIUS
        dx = x - dot['x']
        dy = y - dot['y']
        return (dx * dx + dy * dy) <= (radius * radius)
    
    # =========================================================================
    # STARTUP
    # =========================================================================
    
    def show_startup_countdown(self, seconds):
        """Display countdown before session starts."""
        self.canvas.delete("all")
        
        if seconds > 0:
            self.canvas.create_text(
                self.width // 2, self.height // 2 - 80,
                text="BALANCED THREE-DOT RECORDER",
                font=("Arial", 36, "bold"),
                fill="white"
            )
            self.canvas.create_text(
                self.width // 2, self.height // 2,
                text=f"Starting in {seconds}...",
                font=("Arial", 48, "bold"),
                fill=DOT_B_COLOR
            )
            self.canvas.create_text(
                self.width // 2, self.height // 2 + 60,
                text="Following precomputed path for balanced coverage",
                font=("Arial", 18),
                fill="gray"
            )
            self.canvas.create_text(
                self.width // 2, self.height // 2 + 100,
                text=f"{TARGET_SEGMENTS} segments = 96 combos Ã— 2",
                font=("Arial", 16),
                fill="#f97316"
            )
            
            # Legend
            y_legend = self.height // 2 + 160
            self.canvas.create_oval(self.width // 2 - 200, y_legend - 10,
                                   self.width // 2 - 180, y_legend + 10,
                                   fill=DOT_A_COLOR, outline="")
            self.canvas.create_text(self.width // 2 - 160, y_legend,
                                   text="A = Pass through to start",
                                   font=("Arial", 14), fill=DOT_A_COLOR, anchor="w")
            
            self.canvas.create_oval(self.width // 2 - 10, y_legend - 10,
                                   self.width // 2 + 10, y_legend + 10,
                                   fill=DOT_B_COLOR, outline="")
            self.canvas.create_text(self.width // 2 + 30, y_legend,
                                   text="B = Current target",
                                   font=("Arial", 14), fill=DOT_B_COLOR, anchor="w")
            
            self.master.after(1000, lambda: self.show_startup_countdown(seconds - 1))
        else:
            self.start_session()
    
    # =========================================================================
    # SESSION MANAGEMENT
    # =========================================================================
    
    def start_session(self):
        """Initialize and start recording session."""
        self.session_start_time = time.time() * 1000
        self.is_active = True
        
        # Spawn initial three dots from precomputed path
        self.spawn_initial_dots()
        self.draw_dots()
        self.update_ui()
        
        # Start sampling thread
        self.sampling_thread.start()
    
    def end_session(self):
        """End the recording session."""
        self.is_active = False
        self.recording_enabled = False
        self.sampling_active = False
        
        if self.sampling_thread.is_alive():
            self.sampling_thread.join(timeout=1.0)
        
        self.show_completion_screen()
        
        print(f"\n{'='*60}")
        print("SESSION COMPLETE")
        print(f"{'='*60}")
        print(f"  Segments recorded: {self.segments_recorded}/{TARGET_SEGMENTS}")
        print(f"  Output directory:  {self.output_dir}")
    
    def show_completion_screen(self):
        """Display completion screen."""
        self.canvas.delete("all")
        
        coverage_pct = (self.segments_recorded / TARGET_SEGMENTS) * 100
        
        self.canvas.create_text(
            self.width // 2, self.height // 2 - 60,
            text="âœ“ SESSION COMPLETE",
            font=("Arial", 48, "bold"),
            fill=DOT_A_COLOR
        )
        self.canvas.create_text(
            self.width // 2, self.height // 2 + 20,
            text=f"{self.segments_recorded}/{TARGET_SEGMENTS} segments ({coverage_pct:.0f}% coverage)",
            font=("Arial", 24),
            fill="white"
        )
        self.canvas.create_text(
            self.width // 2, self.height // 2 + 80,
            text=f"Saved to: {self.output_dir}",
            font=("Arial", 14),
            fill="gray"
        )
        
        self.master.after(5000, self.master.destroy)
    
    # =========================================================================
    # DOT SPAWNING - FROM PRECOMPUTED PATH
    # =========================================================================
    
    def spawn_initial_dots(self):
        """Spawn the initial three dots from precomputed path."""
        # A starts at center (first position in path)
        first_pos = PRECOMPUTED_PATH[0]
        self.dot_A = {
            'x': first_pos[2],  # position_x
            'y': first_pos[3],  # position_y
        }
        
        # B is the target for first segment
        self.dot_B = self._get_dot_from_path(0)
        
        # C is the target for second segment (if available)
        if len(PRECOMPUTED_PATH) > 1:
            self.dot_C = self._get_dot_from_path(1)
        else:
            self.dot_C = self.dot_B.copy()
        
        self.path_index = 0
    
    def _get_dot_from_path(self, index):
        """Get dot info from precomputed path at given index."""
        if index >= len(PRECOMPUTED_PATH):
            # Past end of path - use last position
            index = len(PRECOMPUTED_PATH) - 1
        
        dist, orient, pos_x, pos_y = PRECOMPUTED_PATH[index]
        
        # Compute target position (where dot will be placed)
        # The position in the path is where to START, we need to compute where to END
        dx, dy = ORIENT_VECTORS[orient]
        target_x = pos_x + dx * dist
        target_y = pos_y + dy * dist
        
        # Get distance group
        dist_group, dist_name = get_distance_group(dist)
        
        return {
            'x': int(target_x),
            'y': int(target_y),
            'distance': dist,
            'orientation': orient,
            'distance_group': dist_group,
            'distance_name': dist_name,
        }
    
    def shift_dots(self):
        """Shift dots to next positions in precomputed path."""
        # Move to next segment
        self.path_index += 1
        
        if self.path_index >= len(PRECOMPUTED_PATH):
            # Path complete!
            return None
        
        # A becomes current B position
        self.dot_A = {
            'x': self.dot_B['x'],
            'y': self.dot_B['y'],
        }
        
        # B becomes current C
        self.dot_B = self.dot_C.copy() if self.dot_C else self._get_dot_from_path(self.path_index)
        
        # C becomes next target from path
        if self.path_index + 1 < len(PRECOMPUTED_PATH):
            self.dot_C = self._get_dot_from_path(self.path_index + 1)
        else:
            # Last segment - C same as B
            self.dot_C = self.dot_B.copy()
        
        # Compute turn angle
        vec_AB = (self.dot_B['x'] - self.dot_A['x'], self.dot_B['y'] - self.dot_A['y'])
        vec_BC = (self.dot_C['x'] - self.dot_B['x'], self.dot_C['y'] - self.dot_B['y'])
        turn_angle = angle_between_vectors(vec_AB, vec_BC)
        
        return turn_angle
    
    # =========================================================================
    # DRAWING
    # =========================================================================
    
    def draw_dots(self):
        """Draw all three dots with labels."""
        self.canvas.delete("dots")
        
        # Draw connecting lines
        if self.dot_A and self.dot_B:
            self.canvas.create_line(
                self.dot_A['x'], self.dot_A['y'],
                self.dot_B['x'], self.dot_B['y'],
                fill="#333333", width=2, dash=(5, 5), tags="dots"
            )
        if self.dot_B and self.dot_C:
            self.canvas.create_line(
                self.dot_B['x'], self.dot_B['y'],
                self.dot_C['x'], self.dot_C['y'],
                fill="#222222", width=2, dash=(5, 5), tags="dots"
            )
        
        # Draw C (next target)
        if self.dot_C:
            r = DOT_RADIUS - 5
            self.canvas.create_oval(
                self.dot_C['x'] - r, self.dot_C['y'] - r,
                self.dot_C['x'] + r, self.dot_C['y'] + r,
                fill=DOT_C_COLOR, outline="#ffffff", width=2, tags="dots"
            )
            self.canvas.create_text(
                self.dot_C['x'], self.dot_C['y'] - r - 15,
                text="C (next)", font=("Arial", 10, "bold"),
                fill=DOT_C_COLOR, tags="dots"
            )
        
        # Draw B (current target)
        if self.dot_B:
            r = DOT_RADIUS
            self.canvas.create_oval(
                self.dot_B['x'] - r, self.dot_B['y'] - r,
                self.dot_B['x'] + r, self.dot_B['y'] + r,
                fill=DOT_B_COLOR, outline="#ffffff", width=3, tags="dots"
            )
            dist_info = f"{self.dot_B.get('distance', '?')}px {self.dot_B.get('orientation', '?')}"
            self.canvas.create_text(
                self.dot_B['x'], self.dot_B['y'] - r - 15,
                text=f"B ({dist_info})", font=("Arial", 11, "bold"),
                fill=DOT_B_COLOR, tags="dots"
            )
        
        # Draw A (origin)
        if self.dot_A:
            r = DOT_RADIUS
            fill_color = "#90EE90" if self.recording_enabled else DOT_A_COLOR
            self.canvas.create_oval(
                self.dot_A['x'] - r, self.dot_A['y'] - r,
                self.dot_A['x'] + r, self.dot_A['y'] + r,
                fill=fill_color, outline="#ffffff", width=3, tags="dots"
            )
            label = "A (recording...)" if self.recording_enabled else "A (pass through)"
            self.canvas.create_text(
                self.dot_A['x'], self.dot_A['y'] - r - 15,
                text=label, font=("Arial", 11, "bold"),
                fill=DOT_A_COLOR, tags="dots"
            )
    
    def update_ui(self):
        """Update status display - minimal version for low overhead."""
        if not self.is_active:
            return
        
        # Only update the text item, don't recreate
        progress = f"{self.segments_recorded}/{TARGET_SEGMENTS}"
        
        if not hasattr(self, '_status_text_id') or self._status_text_id is None:
            # Create once
            self._status_text_id = self.canvas.create_text(
                self.width // 2, 25,
                text=progress,
                font=("Arial", 14),
                fill="gray", tags="ui"
            )
        else:
            # Update existing text (much faster than delete/recreate)
            self.canvas.itemconfig(self._status_text_id, text=progress)
        
        if self.is_active:
            self.master.after(500, self.update_ui)  # Slower update rate
    
    # =========================================================================
    # SAMPLING LOOP (125Hz)
    # =========================================================================
    
    def _sample_loop(self):
        """Poll mouse position at 125Hz."""
        interval = 1.0 / SAMPLE_RATE_HZ
        next_time = time.perf_counter()
        
        while self.sampling_active:
            now = time.perf_counter()
            
            if self.is_active:
                try:
                    pos = self.mouse_controller.position
                    
                    with self.canvas_lock:
                        canvas_x = pos[0] - self.canvas_x
                        canvas_y = pos[1] - self.canvas_y
                    
                    if 0 <= canvas_x <= self.width and 0 <= canvas_y <= self.height:
                        timestamp = int((time.time() * 1000) - self.session_start_time)
                        
                        # Dot entry detection
                        self._check_dot_entry(canvas_x, canvas_y, timestamp)
                        
                        # Record movement if recording
                        if self.recording_enabled:
                            with self.data_lock:
                                self.segment_trajectory.append((timestamp, canvas_x, canvas_y))
                
                except Exception:
                    pass
            
            next_time += interval
            sleep_time = next_time - time.perf_counter()
            if sleep_time > 0:
                time.sleep(sleep_time)
            else:
                next_time = time.perf_counter()
    
    def _check_dot_entry(self, x, y, timestamp):
        """Check if cursor has entered A or B dot."""
        if timestamp - self._last_trigger_time < self._min_trigger_interval_ms:
            return
        
        # Check A entry (start recording)
        if self.dot_A and not self.recording_enabled:
            inside_A_now = self._is_inside_dot(x, y, self.dot_A)
            
            if inside_A_now and not self._inside_A:
                self._inside_A = True
                self._last_trigger_time = timestamp
                self.master.after(0, lambda: self._trigger_start_recording(x, y, timestamp))
            elif not inside_A_now:
                self._inside_A = False
        
        # Check B entry (complete segment)
        if self.dot_B and self.recording_enabled:
            inside_B_now = self._is_inside_dot(x, y, self.dot_B)
            
            if inside_B_now and not self._inside_B:
                self._inside_B = True
                self._last_trigger_time = timestamp
                self.master.after(0, lambda: self._trigger_complete_segment(x, y, timestamp))
            elif not inside_B_now:
                self._inside_B = False
    
    def _trigger_start_recording(self, x, y, timestamp):
        """Called from main thread to start recording."""
        if not self.recording_enabled:
            self.start_recording(x, y, timestamp)
    
    def _trigger_complete_segment(self, x, y, timestamp):
        """Called from main thread to complete segment."""
        if self.recording_enabled:
            self.complete_segment(x, y, timestamp)
    
    # =========================================================================
    # CLICK HANDLING (backup)
    # =========================================================================
    
    def on_click(self, event):
        """Handle mouse click (backup for pass-through detection)."""
        if not self.is_active:
            return
        
        canvas_x = event.x
        canvas_y = event.y
        timestamp = int((time.time() * 1000) - self.session_start_time)
        
        if timestamp - self._last_trigger_time < self._min_trigger_interval_ms:
            return
        
        if self.dot_A and not self.recording_enabled:
            if self._is_inside_dot(canvas_x, canvas_y, self.dot_A):
                self._inside_A = True
                self._last_trigger_time = timestamp
                self.start_recording(canvas_x, canvas_y, timestamp)
                return
        
        if self.dot_B and self.recording_enabled:
            if self._is_inside_dot(canvas_x, canvas_y, self.dot_B):
                self._inside_B = True
                self._last_trigger_time = timestamp
                self.complete_segment(canvas_x, canvas_y, timestamp)
                return
    
    def start_recording(self, x, y, timestamp):
        """Start recording a new segment."""
        self.recording_enabled = True
        self.segment_start_time = timestamp
        
        with self.data_lock:
            self.segment_trajectory = [(timestamp, x, y)]
        
        self.draw_dots()
    
    def complete_segment(self, x, y, timestamp):
        """Complete current segment and shift dots."""
        # Add final point
        with self.data_lock:
            self.segment_trajectory.append((timestamp, x, y))
            trajectory_copy = list(self.segment_trajectory)
        
        # Save segment
        self.save_segment(trajectory_copy, timestamp)
        
        # Update statistics
        self.segments_recorded += 1
        
        # Compute turn angle
        vec_AB = (self.dot_B['x'] - self.dot_A['x'], self.dot_B['y'] - self.dot_A['y'])
        vec_BC = (self.dot_C['x'] - self.dot_B['x'], self.dot_C['y'] - self.dot_B['y'])
        turn_angle = angle_between_vectors(vec_AB, vec_BC)
        
        # Check if target reached
        if self.segments_recorded >= TARGET_SEGMENTS:
            self.recording_enabled = False
            self.end_session()
            return
        
        # Shift dots to next positions in path
        self.shift_dots()
        
        # Reset entry detection
        self._inside_A = True
        self._inside_B = False
        
        # Keep recording - reset trajectory for next segment
        self.segment_start_time = timestamp
        with self.data_lock:
            self.segment_trajectory = [(timestamp, x, y)]
        
        self.draw_dots()
    
    def save_segment(self, trajectory, end_timestamp):
        """Save segment data to JSON file."""
        segment_num = self.segments_recorded + 1
        
        # Compute vectors
        vec_AB = (self.dot_B['x'] - self.dot_A['x'], self.dot_B['y'] - self.dot_A['y'])
        vec_BC = (self.dot_C['x'] - self.dot_B['x'], self.dot_C['y'] - self.dot_B['y'])
        
        # Distances
        dist_AB = math.hypot(*vec_AB)
        dist_BC = math.hypot(*vec_BC)
        
        # Angles
        angle_AB = math.degrees(math.atan2(vec_AB[1], vec_AB[0]))
        angle_BC = math.degrees(math.atan2(vec_BC[1], vec_BC[0]))
        turn_angle = angle_between_vectors(vec_AB, vec_BC)
        
        # Orientations
        orient_AB = get_orientation_from_angle(angle_AB)
        orient_BC = get_orientation_from_angle(angle_BC)
        
        # Distance groups
        dist_group_AB, dist_name_AB = get_distance_group(dist_AB)
        dist_group_BC, dist_name_BC = get_distance_group(dist_BC)
        
        segment_data = {
            'segment_id': segment_num,
            'timestamp_start': self.segment_start_time,
            'timestamp_end': end_timestamp,
            'duration_ms': end_timestamp - self.segment_start_time,
            
            # Positions
            'A': {'x': self.dot_A['x'], 'y': self.dot_A['y']},
            'B': {'x': self.dot_B['x'], 'y': self.dot_B['y']},
            'C': {'x': self.dot_C['x'], 'y': self.dot_C['y']},
            
            # Current segment (Aâ†’B)
            'AB': {
                'distance': dist_AB,
                'distance_group': dist_group_AB,
                'distance_name': dist_name_AB,
                'angle_deg': angle_AB,
                'orientation': orient_AB,
                'orientation_id': get_orientation_id(orient_AB),
            },
            
            # Next segment (Bâ†’C)
            'BC': {
                'distance': dist_BC,
                'distance_group': dist_group_BC,
                'distance_name': dist_name_BC,
                'angle_deg': angle_BC,
                'orientation': orient_BC,
                'orientation_id': get_orientation_id(orient_BC),
            },
            
            # Turn dynamics
            'turn': {
                'angle_deg': turn_angle,
                'category': get_turn_category(turn_angle),
            },
            
            # Trajectory data
            'trajectory': {
                'length': len(trajectory),
                'x': [int(p[1]) for p in trajectory],
                'y': [int(p[2]) for p in trajectory],
                'timestamps': [p[0] for p in trajectory],
            },
        }
        
        filename = f"segment_{segment_num:04d}.json"
        filepath = os.path.join(self.segments_dir, filename)
        
        with open(filepath, 'w') as f:
            json.dump(segment_data, f, indent=2)


# =============================================================================
# NUMPY IMPORT
# =============================================================================

try:
    import numpy as np
except ImportError:
    class np:
        @staticmethod
        def mean(x):
            return sum(x) / len(x) if x else 0
        @staticmethod
        def std(x):
            if not x:
                return 0
            m = sum(x) / len(x)
            return (sum((xi - m) ** 2 for xi in x) / len(x)) ** 0.5


# =============================================================================
# MAIN
# =============================================================================

def main():
    root = tk.Tk()
    app = BalancedThreeDotRecorder(root)
    root.mainloop()


if __name__ == "__main__":
    main()